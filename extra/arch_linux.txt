LiveUSB арча - чисто консольный. Возможно стоит иметь еще один гуишный, чисто для комфорта.

Инсталлер умеет размечать диск целиком с нуля, но вот можно ли разметить его частично?
Непонятно, может ли он создать subvolume для btrfs, не форматируя весь раздел, а проверять - стремно.

Поэтому либо полная перезапись диска через инсталлер, либо ручная разметка и монтирование.

Подключаем сеть:
    iwctl
        station wlan0 connect ИмяСети
            Дальше вводим пароль
            И wlan0 и ИмяСети подсказываются на таб.
            Если вдруг не видим нужную сеть, то делаем:  station wlan0 scan

Как размечать вручную:
    Информация:
        Посмотри `lsblk` названия устройств, и в `fdisk -l` размер сектора, чтобы не тупить. Дальше все написано в расчете на сектор 512 байт.
        Потом можно использовать гуй `fdisk /dev/nvme0n1` (подставь свое устройство, заметь отсутствие суффикса раздела а-ля `...p1`).
        fdisk умеет только создавать разделы, но не файловые системы в них.
            Не забуть указать тип раздела из списка (например "linux x86-64 root"; а для /efi - тип "EFI System").
            Используй `w` чтобы применить изменения, или `q` чтобы выйти без сохранения.
            Таблицу разделов предпочитай GPT.
        Тебе нужны:
            * раздел для /efi размером в гиг (может и полгига прокатит, вроде инсталлер так предлагает) (в fdisk указывай размер например как +1G, чтобы не считать сектора)
            * промежуток размером в гиг, на всякий.
            * остальное под btrfs (для сектора в 512 байт и /efi в гиг, с отступом в гиг, итоговый начальный сектор тут 4196352)
        Файловые системы создавай руками:
            Для /efi (либо /boot):
                mkfs.fat -F 32 /dev/nvme0n1p42
                Не забудь в fdisk указать тип "1 EFI System".
                Для /efi в parted (!! не в fdisk) нужно сделать `set НОМЕР efi on` (номер смотри в `print`).
                Для /boot то же самое, но `... boot on`. Без этих штук инсталлер откажется устаналивать.
            Для btrfs: (метка по желанию?)
                В fdisk тип можно не трогать, он уже должен стоять "20 Linux Filesystem", что звучит правильно.
                mkfs.btrfs -L SomeLabel /dev/nvme0n1p43
            Для ext4, если он где-то нужен:
                mkfs.ext4 /dev/nvme0n1p44
    Готовые команды:
        fdisk /dev/nvme0n1    (на виртуалке диск может называться `/dev/vda`)
            g  (только если еще нет таблицы разделов)
            n
                <enter>  (number = 1)
                <enter>  (first sector = default (2048 у меня))
                +1G
                Если вдруг спросит про "remove signature" существующей файловой системы, отвечай да.
            n
                <enter>  (number = 2)
                4196352  (дефолтный сектор у меня 2099200, плюс 1 гиг отступа на всякий (+1024^3/512), равно этому числу)
                <enter>  (размер - до конца диска)
            t
                1  (первый наш раздел)
                1  ("EFI System")
            t
                2  (второй наш раздел)
                20  ("Linux Filesystem" - должен быть дефолтом, но почему нет)
            w  (сохраняем изменения)

        mkfs.fat -F 32 -n EFI /dev/nvme0n1p1    (создаем EFI в первом разделе, `-n EFI` - опциональное имя)
        mkfs.btrfs -L Arch /dev/nvme0n1p2       (btrfs в основном разделе, `-L Arch` - опциональное имя)

        parted /dev/nvme0n1 print  (проверяем)
            Должен быть флаг `esp` на разделе EFI. Если что можно поставить его в `parted /dev/nvme0n1` (узнаем номер раздела в print, потом `set 1 esp on`).
            Обрати внимание! В команду передаем имя диска, а не раздела. Если передать раздел, то флаг там не будет видно.

Монтируем созданные вручную разделы:
    Информация:
        Монтируй так:
            mount /dev/устройство /mnt/путь
                --mkdir - сразу создать целевую папку
                для btrfs нужны -o subvol=том,compress=zstd
        размонтировать:
            umount /mnt/...
        Смотреть список монтирований:
            mount
        У btrfs можно временно подмонтировать список subvolumes напрямую, если не указать -o subvol=...
            Тут и compress не нужон, по идее.
            Это для того, чтобы создать новые subvolumes через `btrfs subvolume create /mnt/путь`
            Потом отмонтировать, и перемонтировать уже отдельные subvolumes нормально
            Вроде как compress должен быть везде одинаковый (если разный, то вроде первое монтирование переопределяет следующие)
            Говорят, что compress=zstd (он же zstd:3) хорош, так что используй смело.
        Рекомендуемые (мной) точки монтирования: (инсталлер делает похожие, максимум имена другие и у него /boot вместо /efi)
            @arch_root          -  /                     - btrfs subvolume
            @home               -  /home                 - btrfs subvolume - чтобы легче системы менять
            @arch_snapshots     -  /.snapshots (хм)      - btrfs subvolume - если потом захочешь снапшоты, тут не разбирался еще
            @arch_logs          -  /var/log              - btrfs subvolume - отдельно, чтобы не попадало в снапшоты и не занимало там место
            @arch_package_cache -  /var/cache/pacman/pkg - btrfs subvolume - то же самое
                                   /efi                  - fat32 (либо /boot)
        Смонтируй всю свою иерархию в /mnt, в инсталлере есть опция ее подхватить.
    Команды:
        # Создаем subvolumes:
        mount /dev/nvme0n1p2 /mnt
        btrfs subvolume create /mnt/@{home,arch_{root,snapshots,logs,package_cache}}
        umount /mnt
        # Монтируем для инсталлера:
        mount /dev/nvme0n1p2 /mnt                      -o compress=zstd,subvol=@arch_root
        mount /dev/nvme0n1p2 /mnt/home                 -o compress=zstd,subvol=@home               --mkdir
        mount /dev/nvme0n1p2 /mnt/.snapshots           -o compress=zstd,subvol=@arch_snapshots     --mkdir
        mount /dev/nvme0n1p2 /mnt/var/log              -o compress=zstd,subvol=@arch_logs          --mkdir
        mount /dev/nvme0n1p2 /mnt/var/cache/pacman/pkg -o compress=zstd,subvol=@arch_package_cache --mkdir
        mount /dev/nvme0n1p1 /mnt/efi --mkdir   # !!! не забываем бут-раздел
        # Проверяем:
        mount   (смотрим на последние строчки - ПРОВЕРЬ пути монтирования и имена subvolumes)

Вариант через `archinstall`:

    Archinstall language - оставляем english, это же только инсталлер
    Mirrors - выбираем свою страну
    Locales
        keyboard layout - НЕ ТРОГАЕМ, а то потом на входе в систему застрянем
        locale language - ru_RU.UTF-8   (не уверен что прокатит без `.UTF-8`)
        locale encoding - не трогаем, оставляем UTF-8

    Disk configuration: best effort, brtfs, compress=yes...
        Что интересно, на отдельных subvolumes он с этим показывает compress=false
        (Либо manual partitioning.)

    bootloader -> grub
        unified kernel images - false (это что-то для secure boot, чтобы закатывать в image всякие настройки и подписывать их разом)

    swap - в последних версиях инстуллера предлагают только "swap on zram" (свопать в RAM но сжато). Интересно, попробуем.

    hostname - выбери

    root password - не трогаем, не создаем

    user account - создаем

    profile -> type -> desktop -> xfce (greeter оставляем lightdm-gtk-greeter)
        тут же выбираем драйвер видеокарты

    audio - pipewire (самый новый модный вариант)

    kernels - linux-lts + обычный linux (чтобы была избыточность?)

    network configuration - NetworkManager

    timezone - выбрать

    optional repositories - add multilib (нужен для Wine и Steam - если забыл, его можно потом раскомментировать в sudo nano /etc/pacman.conf - заметь, там нужно раскомментить две строки: [multilib] и за ней Include=...)

    install

    В chroot (или потом) делаем:
        sudo nano /etc/pacman.conf #-> раскомментируем parallel downloads

    reboot


Вариант ручной:
    Сначала настраиваем зеркала, чтобы установка не занимала сто лет.
        Устанавливаем:
            pacman -Sy
                # Скачиваем базу, без этого нельзя ставить пакеты в live usb.
                # Не `-Syu` для скорости.
                # В целом такая команда может быть опасна без `u`, но в этом случае работает норм.
            pacman -S reflector
        Нужно выбрать страну или страны:
            reflector --list-countries | less
                Запоминаем названия стран (длинные или короткие на выбор, т.е. первый или второй столбец).
        Вписываем страны в конфиг:
            nano /etc/xdg/reflector/reflector.conf
                Там раскомментируем `--country` и пишем туда свои страны.
                Похоже, что порядок не важен. Автоматическая сортировка его перебивает.
        Обновляем список зеркал:
            systemctl start reflector
                Эта команда запускает программу `relfector` с флажками из конфига, и пишет результат в `/etc/pacman.d/mirrorlist` - там можешь проверить результат.
        Автозапуск обновления зеркал настроим потом, когда поставим систему.

    Базовая система:
        pacstrap -K /mnt base linux linux-firmware
            # На виртуалках linux-firmware не нужон, я думаю.
            # Тут еще можно использвать `linux-lts` вместо или вместе с `linux` - это альтернативное LTS ядро. На очень новом железе не рекомендую, может каких-то дровов не хватать.
    FSTAB:
        genfstab -U /mnt >>/mnt/etc/fstab
            # `>>` потому что там в начале три строчки комментариев, пусть будут.

    Если настраивал зеркала через reflector как описано выше, скопируй его конфиг тоже:
        mkdir /mnt/etc/xdg/reflector
        cp {,/mnt}/etc/xdg/reflector/reflector.conf

    arch-chroot /mnt   # --- Переходим в chroot, дальше все в нем

    Минимум пакетов:
        pacman -Syu
        pacman -S nano less
    Сеть:
        pacman -S networkmanager network-manager-applet iwd wireless_tools wpa_supplicant
        systemctl enable NetworkManager

    Зеркала: (если настраивал их как написано выше, и скопировал конфиг)
        pacman -S reflector
        Убираем новый конфиг:
            rm /etc/xdg/reflector/reflector.conf.pacnew
        systemctl enable reflector.timer  # Включаем еженедельное авто-обновление.

    Таймзона:
        timedatectl set-timezone $(tzselect)
        # Лучше выбирай родной город, чтобы не поставилась плохая локаль.
    Синхронизация времени:
        systemctl enable systemd-timesyncd

    Локаль: (я бы пропустил этот шаг, локализация в консоли не особо полезна)
        nano /etc/locale.gen
            Раскомменть там `en_US.UTF-8` и `ru_RU.UTF-8`
        locale-gen
        nano /etc/locale.conf
            LANG=ru_RU.UTF-8

    Хостнейм
        nano /etc/hostname
            Туда имя машины

    Бутлоадер:
        touch /etc/vconsole.conf
            Это какая-то новая особенность, раньше он не был нужен.
            Вроде в этом файле ничего полезного, но если интересно, его создание с содержимым описано здесь: https://wiki.archlinux.org/title/Installation_guide#Set_the_console_keyboard_layout_and_font
            Если этого файла нет, то сборка initramfs в команде ниже может сфейлиться. Тогда ее можно перезапустить, удалив или установив `amd-ucode` (или какой-то другой подобный пакет). Более разумного способа перезапустить пока не нашел.
        pacman -S grub efibootmgr btrfs-progs amd-ucode   # или intel-ucode для intel, или ничего для виртуалки
            Я хз, но что-то у меня amd-ucode не ставился без btrfs-progs. Он в любом случае лишним не будет.
            От установки `btrfs-progs` пересобирается initramfs, так что видимо он там полезен.
        grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=ArchGrub
            Здесь /efi - если ты туда монтировал свой раздел (см. самое начало здесь)
            ArchGrub - любое имя
            Может быть такая ошибка:  grub-install: error: efibootmgr failed to register the boot entry: No such file or directory.
                Это значит, что у тебя машина в режиме BIOS, а не UEFI.
                Если это виртуалка в virt-manager - увы, менять поздно, пересоздавай машину.
        grub-mkconfig -o /boot/grub/grub.cfg

    Юзер:
        Создаем:
            useradd -m -g wheel USERNAME
        Пароль:
            passwd USERNAME
        Задаем нормальный шелл:
            chsh USERNAME -s /bin/bash

    Sudo:
        pacman -S sudo
        nano /etc/sudoers
        В самом конце раскомменть `%wheel ALL=(ALL:ALL) ALL`

    Основные пакеты: (часть скопирована из archinstall)
        # Графика: (это соответствует "all open-source" в инсталлере, пусть будет, лишним не будет)
        pacman -S xorg-server xorg-xinit mesa xf86-video-amdgpu xf86-video-ati xf86-video-nouveau xf86-video-vmware libva-mesa-driver libva-intel-driver intel-media-driver vulkan-radeon vulkan-intel
        # Xfce: (выбирай all в этих группах)
        pacman -S xfce4 xfce4-goodies pavucontrol gvfs
            Для wayland можно пропустить xfwm4 и xfwm4-themes, но проще просто поставить все, потому что иксы нужны как зависимости. Также, exo и garcon можно не указывать, они все равно поставятся как зависимости.
        # Прочее:
        pacman -S openssh htop wget smartmontools xdg-utils

    Звук:
        pacman -S pipewire pipewire-alsa pipewire-jack pipewire-pulse gst-plugin-pipewire libpulse wireplumber sof-firmware
        su USERNAME
        systemctl --user enable pipewire-pulse    # БЕЗ SUDO!

    Экран входа в систему:
        pacman -S lightdm lightdm-gtk-greeter
        systemctl enable lightdm

    # --- ребутаемся в систему, дальше оттуда!
    Ctrl+D - выходим из chroot
    shutdown now
    вынимаем live usb
    включаем

    Пока все.



XFCE с Wayland:
    Основано на: https://github.com/crispinprojects/xfce4-wayland

    Ставим композитор:
        pacman -S labwc
            Если спросит, какой взять ttf-font, наверное лучше noto-fonts
        yay -S labwc-tweaks-git
            Гуй настроек для labwc, можно отдельно поставить потом.
        Обрати внимание, что `startxfce4 --wayland` заставляет labwc грузить конфиги из кастомной папки: `~/.config/xfce4/labwc`, вместо обычного `~/.config/labwc`.
        Для запуска `labwc-tweaks` важно поставить переменную `LABWC_CONFIG_DIR=.config/xfce4/labwc`, иначе он будет работать не с той папкой, и изменения не будут применяться.
            Предлагаю в ярлыке использовать `env LABWC_CONFIG_DIR=.config/xfce4/labwc labwc-tweaks`.

    Тестовый запуск wayland-сессии:
        systemctl disable lightdm
        Ребутаемся в консоль.
        startxfce4 --wayland

    Постоянный запуск wayland-сессии:
        sudo mkdir /usr/local/share/xsessions/
        sudo nano /usr/local/share/xsessions/xfce4_wayland.desktop
            Туда пишешь:
                [Desktop Entry]
                Name=Xfce4 with Wayland
                Exec=startxfce4 --wayland
        Дальше запускаешься в lightdm, и в правом-верхнем углу выбираешь `Xfce Session (Wayland)`.
        Заметь, что похоже `Name` игнорируется (и наверное имя файла тоже).
        Проверь, что используешь wayland:
            echo $XDG_SESSION_TYPE

    Разрешение:
        pacman -S wlr-randr
            Дальше используй его как xrandr.
        pacman -S kanshi
            Это автоматически применяет профили мониторов, когда они подключаются.
            Нужно руками писать конфиг:
                https://wiki.archlinux.org/title/Kanshi
